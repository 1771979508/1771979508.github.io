<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[牛客网上周题目整理]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E4%B8%8A%E5%91%A8%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86(20190624-20190630)%2F</url>
    <content type="text"><![CDATA[写在开始整理一下上周（2019/06/24-2019/06/30）收藏的值得研究的题目&#8195;&#8195; 一、当我们需要所有线程都执行到某一处，才进行后面的代码执行时我们可以使用：CountDownLatch &#8195;&#8195; [ Java主线程等待所有子线程执行完毕再执行 ]这个需求其实我们在工作中经常会用到，比如用户下单一个产品，后台会做一系列的处理，为了提高效率，每个处理都可以用一个线程来执行，所有处理完成之后才会返回给用户下单成功。 并发工具类等待多线程完成的CountDownLatch：其不可能重新初始化或者修改CountDownLatch对象内部计数器的值，一个线程调用countdown方法happen-before另外一个线程调用await方法 1234567891011121314151617181920public class test&#123; public static void main(String[] args) throws InterruptedException&#123; final CountDownLatch latch = new CountDownLatch(5); for(int i=0;i&lt;5;i++)&#123; new Thread(new Runnable()&#123; public void run()&#123; try&#123; Thread.sleep(1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;子线程执行！！&quot;); latch.countDown(); // 让latch中的数值减1 &#125; &#125;).start(); &#125; latch.await(); // 阻塞当前线程直到latch中的值为0 System.out.println(&quot;主线程执行！&quot;); &#125;&#125; 同步屏障CyclicBarrier 123456789101112131415161718192021222324public class test&#123; public static void main(String[] args) throws InterruptedException,BrokenBarrierException&#123; final CyclicBarrier barrier = new CyclicBarrier(5); for(int i=0;i&lt;4;i++)&#123; new Thread(new Runnable()&#123; public void run()&#123; try&#123; Thread.sleep(1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;子线程执行！！&quot;); try&#123; barrier.await(); // 到达屏障 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; barrier.await(); // 阻塞当前线程直到latch中的值为0 System.out.println(&quot;主线程执行！&quot;); &#125;&#125; 两者区别（CountDownLatch和CyclicBarrier）1countDownLatch只能使用一次，而CyclicBarrier方法可以使用reset()方法重置，所以CyclicBarrier方法可以能处理更为复杂的业务场景 &#8195;&#8195; 二、一道题不知道为啥：123String str =&quot;&quot;;System.out.print(str.split(&quot;,&quot;).length()); &#8195;&#8195;结果输出为1&#8195;&#8195;why? &#8195;&#8195; 三、关于引用传递和值传递：123456引用数据类型是引用传递，基本数据类型是值传递值传递不可以改变原变量的内容和地址：因为Java方法的形参传递都是原变量的副本，在方法中改变的是副本的值；而不适合原变量的引用传递不可以改变原变量的地址，但可以改变原变量的内容：当副本的引用改变的时候，原变量的引用并没有变化，当副本改变内容时，由于副本引用指向的是原变量的地址空间，所以原变量的内容发生变化结论： 1.值传递不可以改变原变量的内容和地址； 2.引用传递不可以改变原变量的地址，但可以改变原变量的内容； &#8195;&#8195; 四、下面输出结果为false的是：1234Integer i01=59;int i02=59;Integer i03=Integer.valueOf(59);Integer i04=new Integer(59); 解析一： 解析二：123456789101112131415161718192021222324252627282930313233343536373839首先常量池这个概念，原来以为只要是一个整型，都会放进到常量池，比如，0,1,12222222等。查找后发现，Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127并且大于等于-128时才可使用常量池，因为他们至占用一个字节(-128~127);再者Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;所以如果你测试如下代码public static void main(String[] args) &#123; Integer a = 127; Integer b = 127; Integer c = 128; Integer d = 128; System.out.println(a == b); System.out.println(c == d);&#125;结合自动封装、常量池以及Integer.valueOf方法就不难得出，答案时 true和false； 再看本题：Integer i01=59;int i02=59;Integer i03=Integer.valueOf(59);Integer i04=new Integer(59);第一行：由于59在-128~127范围之内，所以在自动装箱的时候，会返回IntegerCache[59 - (-128)];第三行：同第一行第四行：因为有new关键字，所以在heap中开辟了一块新内存放置值为59的Integer对象。System.out.println(i01==i02);//正确System.out.println(i01==i03);//正确，都指向IntegerCache[59-(-128)]对象System.out.println(i03==i04);//错误，引用指向的对象地址不同System.out.println(i02==i04);//正确 &#8195;&#8195; 五、假设 a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量，则线程 1 和线程 2 同时执行下面的代码，最终 a 的结果不可能是（）：1234567boolean isOdd = false;for(int i=1;i&lt;=2;++i)&#123; if（i%2==1）isOdd = true； else isOdd = false； a+=i*(isOdd?1:-1)；&#125; 解析：如图：1234易知：每个线程对a 均做了两次读写操作，分别是 “ +1 ” 和 “ -2 ”而题目问了是最终a 的结果，所以 a 的结果取决于各自线程对 a 的先后读写的顺序结论：a的可能取值为-1、0、-2]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网上周题目整理]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E4%B8%8A%E5%91%A8%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86(20190609-20190616)%2F</url>
    <content type="text"><![CDATA[写在开始整理一下上周（2019/06/09-2019/06/16）收藏的值得研究的题目 数据类型转换1以下b的值是：byte b = (byte)129 基础&#8195;&#8195;byte，一个字节，一个字节有8位的二进制数，它的可表示范围是[128-127],来看一下计算过程：首先在计算机中它只认识0和1，在计算方面是以补码的形式呈现； 123在一串二进制数中，最高为表示符号的正负，0为整数，1为负数； 对于正整数而言，原码、反码和补码都是一样的; 12345678910举个例子：如127 符号位 数值位 源码表示 0 1111111 反码表示 0 1111111 补码表示 0 1111111我们可以得到 127 这个整数在计算机中的存在形式以及表现的补码为 01111111我们再回过来可以验证一下： 1*2^0+1*2^1+1*2^2+1*2^3+1*2^4+1*2^5+1*2^6+0*2^7 = 1+2+4+8+16+32+64+0=127 12对于负整数而言，反码表示为原码的最高位置不变，其它位全部取反 补码为反码的值加1 123456789举个例子：如-127 符号位 数值位 源码表示 1 1111111 反码表示 1 0000000 补码表示 1 0000001验证一下： -1*2^7+1*2^0=-127 byte的最大值和最小值12345678910111213最大值： 最高位为整数，其它为1，得到01111111 经过等比公式计算得到值为：127 max=127最小值： 对于负整数-0，二进制表示为100000000(补码) 10000000(原码) 由于正整数0和负整数-0相等，但是它们的二进制表示形式却不一样并且-0还是9位二进制表示的，所以为了解决这个问题，就让10000000表示为-128即 min=-128 123456789所以我们能得到： 每个数据都是由8位二进制表示，每一位都有2种可能(0或者1)，所以8位二进制可以组合的数据个数为： sum = 2^8=256 正整数从0~127共sum1=128个，负整数从-1~-128共128个 sum1 + sum2 =sum即从这个角度也可以说明最小范围为-128，最大范围为127。 分析上述题目&#8195;&#8195;首先知道129补码的二进制形式为：00000000 00000000 00000000 10000001 &#8195;&#8195;又知道正数的补码和原码相同 &#8195;&#8195;我们截取出来10000001，很明显这是一个负数，补码-1=反码 &#8195;&#8195;得到反码：10000000,反码转原码得到(符号位不变)：111111111 &#8195;&#8195;现在我们得到的原码是11111111再经过转反码求补码得到123456符号位 数值位 源码表示 1 1111111 反码表示 1 0000000 补码表示 1 0000001最后的结果：-1*2^7+1*2^0=-127 关于JVM的内存 12345678910111213141516171819202122232425运行时数据区包括：虚拟机栈区、堆区、方法区、本地方法栈、程序计数器虚拟机栈区：常说的栈区，线程私有，存放基本类型，对象的引用和returnAddress，在编译期间完成分配堆区：Java堆，也称GC堆，所有线程共享，存放对象的实例和数组，Java堆是垃圾收集器管理的主要区域方法区：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载程序计数器：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址运行流程： 程序（非多线程）开始运行的时候，在系统中会自动分配一个栈，这个时候程序计数器就开始起到作用了，它会指示jvm对编译之后的字节码的执行方向，同时在执行一个方法的时候就会在栈中分配一个属于方法一个栈帧，方法的局部变量都会存放在这个栈帧中，其生命周期随着方法的结束而释放，这里强调一点的是先进后出的逻辑，堆中的数据当没有对象引用的时候就成了孤立数据，此时就会被GC垃圾回收器对其进行内存释放。 方法区包含了常量池：存放类信息、常量、静态变量、即时编译器编译后的代码等。其中静态成员变量在类装载的时候就进行了创建，在整个程序结束时按序销毁。 静态成员变量在类装载的时候就进行了创建，在整个程序结束时按序销毁。 实例变量在类实例化对象时候创建，在对象销毁的时候销毁。 局部变量在局部范围使用时创建，跳出局部范围销毁。 关于编译期和运行期： 编译期：就是将源码编译成二进制的.class字节码文件，并将文件放到了磁盘中， 编译期相当于只是做了一个翻译的过程 运行期：这块就是我们java解释器将二进制.class字节码解释成程序能识别的程序（将磁盘中的代码放到内存中就是类加载过程 线程12345678910111213 public class Bground extends Thread&#123; public static void main(String argv[])&#123; Bground b = new Bground(); b.run(); &#125; public void start()&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(&quot;Value of i = &quot;+i); &#125; &#125; &#125;运行这段代码得到什么结果？ 1234567891011分析： 开启线程的方法是start()方法：让线程从new变成runnable，run()方法是执行体的入口 这里的run方法使用的是父类的方法，需要有target这个对象，但很明显这里并没有初始化，所以运行这段代码什么也不会发生 @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 12345678910111213141516线程创建： 1.子类（ExtendsThread）继承Thread，子类开启start() // 启动线程 - 创建子类对象，调用子类对象的start方法 ExtendsThread extendsThread = new ExtendsThread(); extendsThread.start(); 2.类ImplRunnable实现Runnable，创建代理对象 // 创建实现类对象// ImplRunnable implRunnable = new ImplRunnable();// // 创建代理类对象// Thread thread = new Thread(implRunnable);// thread.start(); // 一个对象只使用一次则可以使用匿名类 - 可以不用申明引用 new Thread(new ImplRunnable()).start();; 分析代码123456789101112131415161718192021222324252627282930package Test;public class Test &#123; private static void test(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; try &#123; if (arr[i] % 2 == 0) &#123; throw new NullPointerException(); &#125; else &#123; System.out.print(i); &#125; &#125; finally &#123; System.out.print(&quot;e&quot;); &#125; &#125; &#125; public static void main(String[]args) &#123; try &#123; test(new int[] &#123;0, 1, 2, 3, 4, 5&#125;); &#125; catch (Exception e) &#123; System.out.print(&quot;E&quot;); &#125; &#125; &#125;分析： 由于arr[0] =0,所以在进入 test()方法里面会在第一个if 上抛出一个 NullPointerException,接着会执行 finally 的语句, (finally语句先于 return 和 throw语句执行)， 输出一个&apos;e，然后回到 main方法中，由于捕捉到异常，所以进入到catch语句中，然后打印一个&apos;E&apos;,所以最终结果为&quot;eE&quot;]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ss科学上网]]></title>
    <url>%2F2019%2F06%2F09%2Fss%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[只是记录一下 1234567891011121314先安装git yum -y install git克隆项目 git clone -b master https://github.com/flyzy2005/ss-fly设置密码和端口 ss-fly/ss-fly.sh -i flyzy2005.com 1024加速 ss-fly/ss-fly.sh –bbr查看是否启动加速 sysctl net.ipv4.tcp_available_congestion_control]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>ladder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魃]]></title>
    <url>%2F2019%2F06%2F07%2F%E9%AD%83%2F</url>
    <content type="text"><![CDATA[待更新 写在开始]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图和递归]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%9B%BE%E5%92%8C%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[图的相关知识以及用递归实现的一些算法 写在开始本周共实现算法：温故而知新1234数组的二分查找 矩形递归 二分查找实现旋转数组的最小值 - 两种实现方式 非递归方式的二叉树的层次遍历以及中序遍历 &#160; &#160; &#160; &#160;现在渐渐开始养成了每天都往仓库提交点什么，无论提交的是理论的知识还是实现的代码，总归是记录成长的见证。 场景我们小时候玩的迷宫，走到死胡同返回再去寻找有出路的新节点，尝试新的路径，往复循环直到找到出口，那么它是怎么记录下来路径，又是怎么去寻找到新节点的？微博和微信，用户之间能够互相关注和互相添加好友；抖音等系统机制能给你推荐你的好友，以及地图的最远和最近等机制怎么实现的？ 图上周认识到了图这种数据结构，发现这种数据结构真的是好啊。然后我越来越真切地感受到，很多知识都是基于生活演变而来，仔细一想很多知识不就是为了解决生活中问题的么。 什么是图?图由顶点集合与描述各顶点之间边组成的一种数据结构图分为有向和无向如下图是有向图和无向图两种：我们都知道在使用的地图(无论是百度地图还是高德地图)它们都有帮我识别远近的，以及推荐最优解的功能那是怎么实现的？事实上，这里引入了一个概念带权图:在每个顶点之间的边上都会有一个权重(weight)，通过它的和，会知道那条路径会更短以及用时最快 图的储存图存储方式有链表+数组和邻接矩阵储存的过程如上图，需要求解时间最少，距离最短，权值最小的最短路径通过一种算法：狄克斯特拉算法上图中共有8个地方，初始用如下方法记录 - 暂且认为从起点到v2-v8的距离均为-1(无穷大)12345678910S数组 v1T数组 v2 v3 v4 v5 v6 v7 v8前一个节点 当前节点 权重 v2 -1 v3 -1 v4 -1 v5 -1 v6 -1 v7 -1 v8 -1 经过最终的运算得到如下数组:12345678910111213141516s数组 v1 v2 v3 v4 v6 v7 v5 v8t数组前一个节点 当前节点 权重 v1 v2 3 v2 v3 4 v3 v4 5 v6 v5 8 v3 v6 6 v6 v7 7 v7 v8 12最短路径路线 v1 v2 v3 v6 v7 v8 12 3 1 2 1 5下面的数字代表的是：各个节点之间的距离 【最终结果表】 从上面那种表可以看出来，我们能够得到从v1到v2、v3等各个点之间的最短距离；狄克斯特拉算法实现过程：首先是：v1节点到最近的三个节点v2、v3、v4以及他们的权重是否大于初始值(-1)。如果大于则进行更新,所以得到如下：123456789101112131415161718192021222324252627v1节点： 前一个节点 当前节点 权重 上一个节点到当前节点的权重值 v1 v2 -1 3 v1 v3 -1 5 v1 v4 -1 6 v5 -1 v6 -1 v7 -1 v8 -1更新完了之后：将原本的`-1`替换掉最新的权重值, 如果[权重小于原本的权重]则进行替换 前一个节点 当前节点 权重 v1 v2 3 v1 v3 5 v1 v4 6 v5 -1 v6 -1 v7 -1 v8 -1数组表一： s数组 v1 v2 t数组 v3 v4 v5 v6 v7 v8 【表格一】 然后接下来，在【上一个节点到当前节点的权重值】这一栏中找到最小的值，即[3] - 对应当前节点最小的值：v2 ，得到【表格一】中的数组表一;1v1能到达的顶点已经走完了，现在看v2的能到达的顶点路径 1234567891011121314151617181920212223242526272829v2节点 - 能到最近节点的图 - (v5、v6、v3) - 则路径为[v1-v2-v3]、[v1-v2-v5]、[v1-v2-v6] 前一个节点 当前节点 权重 上一个节点到当前节点的权重值 v1 v2 3 v1 v3 5 1 v1 v4 6 v5 -1 v6 -1 7 v7 -1 4 v8 -1 更新完了之后：将原本的`-1`替换掉最新的权重值，如果[权重小于原本的权重]则进行替换，以及[前一个节点的名称] 前一个节点 当前节点 权重 v1 v2 3 v2 v3 1+3 v1 v4 6 v2 v5 7+3 v2 v6 4+3 v7 -1 v8 -1 数组表二： s数组 v1 v2 v3 t数组 v4 v5 v6 v7 v8 【表格二】 接下来就是循环前面的操作，直到走完v1-v8的所有路径，得到最终结果表详情可以了解 &nbsp;&nbsp; b站上面尚学堂的数据结构与算法 申明文章中的图片均非本人的原创，转自极客时间-王争专栏的图，若有打扰请联系本人进行删除;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>sc数据结构与算法hedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归出口在哪？ 写在开始本周有一个需求：就是需要完成一颗树结构递归呐，递归]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法复杂度分析和算法实现]]></title>
    <url>%2F2019%2F05%2F19%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常见算法的时间复杂度分析和栈实现队列、队列实现栈 写在开始刷题和sql在以后就只记录一些有意思的题目或分析；如：关于几个常见算法的时间复杂度分析案例：12345678(1).交换i和j的内容 sum=0; (一次) for(int i=0;i&lt;=n;i++&gt;)&#123; (n次) for(j=1;j&lt;=n;j++&gt;)&#123; (n^2次) sum++; (n^2次) &#125; &#125;则时间复杂度T(n) = 1+n+2*n^2 取最高次的影响则为 T(n) = O(n^2) 1234567(2). for (i=1;i&lt;n;i++)&#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) (因为j能取到2n所以为：2n+1) x++; ② &#125; ① 的时间复杂度是(n-1)、② 的时间复杂度是(n-1)(2n+1) 则时间复杂度为T(n) = O(n-1)+(n-1)(2n+1) = O(n^2) 12345678(3). a=0; b=1; ① (1次) for(i=1;i&lt;=n;i++)&#123; ② (n+1次) s=a+b; ③ (n次) b=a; ④ (n次) a=s; ⑤ (n次) &#125; 则时间复杂度为：T(n) = 4n = O(n) 为线性的函数 123456(4). i=1; ① 1 while(i&lt;=n&gt;)&#123; i=i*2; ② 2^f(n)&lt;=n;f(n)&lt;=log2n &#125; T(n)=O(log2n) 这里频次本身是一个函数，则可求得函数本身f(n)的值 本周实现算法 1.用两个栈实现队列 - 完成基本的出队和入队的功能 123456789101112131415161718192021222324252627282930313233343536373839404142/*基本分析：由于栈和队列的两种结构是完全相反的*/ public class ImplQueueByStack&#123; // 定义两个栈 Stack&lt;Integer&gt; stackA = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stackB = new Stack&lt;Integer&gt;(); // 定义入队的方法 public void push(int node)&#123; // 将栈A当作队列的入口 stackA.push(node); &#125; // 队列的出队方法 public int pop() throws Exception&#123; if(stackA.isEmpty() &amp;&amp; stackB.isEmpty())&#123; throw new Exception(&quot;队列为空&quot;); &#125; // 将栈B当作队列的出口,拿到栈A中的最后一个元素进行出栈 if(stackB.isEmpty())&#123; // 如果栈B为空的话，遍历栈A往栈B中添加元素 while(!stackA.isEmpty())&#123; stackB.push(stackA.pop()); &#125; &#125; // 添加返回值 return stackB.pop(); &#125; // 测试方法 public static void main(String[] args) throws Exception &#123; ImplQueueByStack implQueueByStack = new ImplQueueByStack(); implQueueByStack.push(2); implQueueByStack.push(4); implQueueByStack.push(0); System.out.println(implQueueByStack.pop()); implQueueByStack.push(10); implQueueByStack.push(20); System.out.println(implQueueByStack.pop()); &#125; &#125; 2.用两个队列实现栈 - 完成基本的出队和入队的功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public class ImplStackByQueue&#123; // 定义两个队列 Queue&lt;Integer&gt; queueA = new Queue&lt;Integer&gt;(); Queue&lt;Integer&gt; queueB = new Queue&lt;Integer&gt;(); //定义队列的入队方法 public void push(int node)&#123; // 如果队列A为空，则队列B Push if(queueA.isEmpty())&#123; queueB.push(node); &#125; if(queueB.isEmpty())&#123; queueA.push(node); &#125; // 如果两个队列均为空的话，使用队列A优先 if(queueA.isEmpty() &amp;&amp; queueB.isEmpty())&#123; queueA.push(node); &#125; &#125; // 定义出队的方法 public int pop() throws Exception&#123; if(queueA.isEmpty() &amp;&amp; queueB.isEmpty())&#123; throw new Exception(&quot;栈为空&quot;); &#125;// 如果queueA为空，queueB不为空，将queueB的元素依次放入queueA，直到queueB中最后一个元素弹出 if(!queueA.isEmpty())&#123; while(queueB.size()&gt;1)&#123; queueA.add(queueB.poll()); &#125; return queueB.poll(); &#125; if(!queueB.isEmpty())&#123; while(queueA.size()&gt;1)&#123; queueB.add(queueA.poll()); &#125; return queueA.poll(); &#125; &#125; public static void main(String[] args) throws Exception &#123; ImplStackByQueue implStackByQueue = new ImplStackByQueue(); ImplStackByQueue.push(2); ImplStackByQueue.push(4); ImplStackByQueue.push(0); System.out.println(ImplStackByQueue.pop()); ImplStackByQueue.push(10); ImplStackByQueue.push(20); System.out.println(ImplStackByQueue.pop()); &#125; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[做一个执行者而不是计划者 Beginning从上周开始写博客开始，我就开始计划了我后面每天要做的事情;目前已经开始执行了一周，然后到了周天的总结时间； 牛客网刷题首先是每天早上在公交上刷Java基础题目，每天，很惨呐😭；可以看出来Java的基础真的很差劲，但是目前的阶段主要在补充一些数据结构与算法的知识，所以就每天早上挤公交的时候刷刷题，到下阶段着重看Java;总结：关于Java基础，我相信很多人和我一样，面象google编程；再就是看了源码但过了一段时间又忘记了，所以我选择了每天刷点题，着重提高对数据结构与算法的认知，希望几个月后我能得到自己的肯定； 数据结构与算法这里刷的是剑指offer，虽然很多不懂,走的很慢，但慢慢磨总归是可以磨出来的;这周主要做了两道算法题目：一道是：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList，另一道是：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。；其中链表的那道题目：给我印象最深的就是通过栈结构来实现的，这里充分地利用了栈结构先入后出的特性；以及递归方法，这也让我再次体会到了递归的强大；12345678910111213// 3.使用栈public ArrayList&lt;Integer&gt; printListFromTailToHeadStack(ListNode listNode)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while(listNode != null)&#123; stack.add(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while(!stack.isEmpty())&#123; ret.add(stack.pop()); &#125; return ret;&#125; 12345678910111213// 递归实现 - 把后面未遍历的当成一个整体，然后调用自己的方法，这样理解起来就很方便了LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(listNode != null)&#123; ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); //System.out.println(ret); &#125; System.out.println(ret); return ret; &#125; 然后关于树:学习了树的结构以及二叉树深度优先遍历和广度有限遍历,其中前序遍历,中序遍历,后序遍历三种深度遍历的方式。当然我自己根据题目给出的前两种遍历结构试着自己画了一下二叉树的结构，结果就是很容易把左边的树画出来，而右边的怎么都感觉不对劲；后面看了别人的思路也觉得画的有问题😚；可能还没有理解透彻，需要被再多折磨一下；总结：虽然算法在很多时候自己可能写不出来，但是硬着头皮去啃坚持一个阶段下来即使不能达到自己能随手写出来那种地步也会对整体的结构有一个比较清晰的脉络，值得深究； 关于SQL同样是在下午吃完饭回来进行练习，SQL的练习要比我想象中进展的快：计划是每周5道左右，目前来看貌似已经超两倍的完成；感觉牛客的SQL练习不大能起效果:就目前练习的来看基本都是两张表带点简单的条件以及排个序没有达到我想要的效果，可也能没做到后面的题目；改善：针对次可能需要进行改变一下，增加数据结构与算法的看书时间，先看算法书再练习SQL； 阶段总结目前来看，周一到周五基本能够完成上述的任务；周六周天主要写小程序和写文章、看书等任务周六和周天尚欠缺自制力，不能最大化的利用时间；希望能够有所改进；]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客从0到1]]></title>
    <url>%2F2019%2F05%2F02%2Fhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BB%8E0%E5%88%B01%2F</url>
    <content type="text"><![CDATA[写在开始这篇文章主要记录这两天倒腾的hexo个人博客系统从0到1的过程。 平台虽说是基于windows平台的搭建,但是很多命令都是一样的，所以想在Linux里面尝试的不妨倒腾两手 正文 Git的安装git是个好工具，和svn一样主要用于版本控制，我们需要在 git bush里面进行命令行的操作。有关git的相关知识可以到廖雪峰的网站进行学习； NodeJS的安装NodeJS也是个好东西，这玩意儿居然能写js的后端，一句话流批。NodeJS主要是用来管理和配置npm包的，安装完成需要配置一下环境变量，然后打开cmd，输入会有对应的版本号 12node -vnpm -v hexo的安装安装好工具之后开始操作：首先建立一个hexo文件的目录；例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装。 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后localhost:4000(默认开启4000端口)就能看到自己的静态资源站了 调整相关hexo样式这里一般就是先选好自己想用哪个主题样式用npm包clone下来，然后在主题文件夹下的配置文件改。如：日期啊，分页啊，用哪种样式等等，这里就不一一介绍了。这里可以参考hexo官网，看看它的目录结构以及受欢迎的主题。我看很多人用的Next主题，简洁而不简单 蛮不错的。 到这里应该都能访问到本机服务上的博客了。接下来主要做的就是将本地代码部署到远端GitHub上去。 部署到GitHub上并解析自己的域名 建立仓库值得注意的是，这里命名规则是账号名.github.io这个是后面你访问的域名(如果不绑定自己的域名的话) 设置git的名字和邮箱设置命令 1git config --global user.name &apos;账号名&apos; 查看是否设置成功的命令 1git config --global user.name 邮箱同理 1git config --global user.email &apos;邮箱&apos; 配置SSH密匙配置密匙命令 1ssh-keygen -t rsa -C &apos;邮箱名&apos; 查看是否设置成功 1ssh -T git@github.com 打开生成好密匙的文件id_rsa.pub，进入GitHubsetting--&gt;SSH and GPG keys--&gt;New SSH key复制粘贴保存 部署打开D:\hexo，用sublime或者VS code打开根目录下的_config.yml文件，文件最后可以看到 12deploy: type: 修改其配置 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github branch: master 然后就是一套,你可以选择将它们写到bat脚本执行文件里面去 123$ hexo clean$ hexo g$ hexo d 当然这里如果你没有安装部署的命令的话需要如下操作 1$ npm install hexo-deployer-git --save 这时，你就可以在浏览器里面输入https://yourname.github.io来进行访问你的博客了; 将域名解析到对应的GitHub仓库地址(可选)如果你有自己的域名的话或者你想拿自己的域名做链接的话，你需要到对应的云平台域名解析设置两条www和@的解析设置,其中记录类型为CNAME和记录值为账号名.github.io。进入{yourname}.github.io仓库--&gt;Settings-&gt;GitHub Pages保存好域名即可。到D:\hexo\sourse目录下（即你安装hexo的目录下的sourse目录下）新建文件CNAME，用Sublime或者VS code打开,填入你的域名，如jokerq.com，保存。然后到D:\hexo目录下用sublime打开_config.yml，ctrl+f查找skip_render，然后改为 123skip_render: - README.md - CNAME 最后就是执行你的bat文件，大功告成!]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>静态博客系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[逍惆]]></title>
    <url>%2F2019%2F04%2F28%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[小丑的世界逍惆的第一篇blog 列表1 列表2 a 子列表 b 子列表 列表3 小丑的世界 字体变斜 字体加粗 &lt;html&gt;&lt;/html&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是代码片段&lt;/title&gt; &lt;/head&gt; &lt;body&gt; conole.log(我是打印的函数); &lt;/body&gt;&lt;/html&gt; 引用别人的代码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>

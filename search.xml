<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[涘]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%8B%88%2F</url>
    <content type="text"><![CDATA[路漫漫 写在开始刷题和sql在以后就只记录一些有意思的题目或分析；如：关于几个常见算法的时间复杂度分析案例：12345678(1).交换i和j的内容 sum=0; (一次) for(int i=0;i&lt;=n;i++&gt;)&#123; (n次) for(j=1;j&lt;=n;j++&gt;)&#123; (n^2次) sum++; (n^2次) &#125; &#125;则时间复杂度T(n) = 1+n+2*n^2 取最高次的影响则为 T(n) = O(n^2) 1234567(2). for (i=1;i&lt;n;i++)&#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) (因为j能取到2n所以为：2n+1) x++; ② &#125; ① 的时间复杂度是(n-1)、② 的时间复杂度是(n-1)(2n+1) 则时间复杂度为T(n) = O(n-1)+(n-1)(2n+1) = O(n^2) 12345678(3). a=0; b=1; ① (1次) for(i=1;i&lt;=n;i++)&#123; ② (n+1次) s=a+b; ③ (n次) b=a; ④ (n次) a=s; ⑤ (n次) &#125; 则时间复杂度为：T(n) = 4n = O(n) 为线性的函数 123456(4). i=1; ① 1 while(i&lt;=n&gt;)&#123; i=i*2; ② 2^f(n)&lt;=n;f(n)&lt;=log2n &#125; T(n)=O(log2n) 这里频次本身是一个函数，则可求得函数本身f(n)的值 本周实现算法 1.用两个栈实现队列 - 完成基本的出队和入队的功能 123456789101112131415161718192021222324252627282930313233343536373839404142/*基本分析：由于栈和队列的两种结构是完全相反的*/ public class ImplQueueByStack&#123; // 定义两个栈 Stack&lt;Integer&gt; stackA = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stackB = new Stack&lt;Integer&gt;(); // 定义入队的方法 public void push(int node)&#123; // 将栈A当作队列的入口 stackA.push(node); &#125; // 队列的出队方法 public int pop() throws Exception&#123; if(stackA.isEmpty() &amp;&amp; stackB.isEmpty())&#123; throw new Exception(&quot;队列为空&quot;); &#125; // 将栈B当作队列的出口,拿到栈A中的最后一个元素进行出栈 if(stackB.isEmpty())&#123; // 如果栈B为空的话，遍历栈A往栈B中添加元素 while(!stackA.isEmpty())&#123; stackB.push(stackA.pop()); &#125; &#125; // 添加返回值 return stackB.pop(); &#125; // 测试方法 public static void main(String[] args) throws Exception &#123; ImplQueueByStack implQueueByStack = new ImplQueueByStack(); implQueueByStack.push(2); implQueueByStack.push(4); implQueueByStack.push(0); System.out.println(implQueueByStack.pop()); implQueueByStack.push(10); implQueueByStack.push(20); System.out.println(implQueueByStack.pop()); &#125; &#125; 2.用两个队列实现栈 - 完成基本的出队和入队的功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public class ImplStackByQueue&#123; // 定义两个队列 Queue&lt;Integer&gt; queueA = new Queue&lt;Integer&gt;(); Queue&lt;Integer&gt; queueB = new Queue&lt;Integer&gt;(); //定义队列的入队方法 public void push(int node)&#123; // 如果队列A为空，则队列B Push if(queueA.isEmpty())&#123; queueB.push(node); &#125; if(queueB.isEmpty())&#123; queueA.push(node); &#125; // 如果两个队列均为空的话，使用队列A优先 if(queueA.isEmpty() &amp;&amp; queueB.isEmpty())&#123; queueA.push(node); &#125; &#125; // 定义出队的方法 public int pop() throws Exception&#123; if(queueA.isEmpty() &amp;&amp; queueB.isEmpty())&#123; throw new Exception(&quot;栈为空&quot;); &#125;// 如果queueA为空，queueB不为空，将queueB的元素依次放入queueA，直到queueB中最后一个元素弹出 if(!queueA.isEmpty())&#123; while(queueB.size()&gt;1)&#123; queueA.add(queueB.poll()); &#125; return queueB.poll(); &#125; if(!queueB.isEmpty())&#123; while(queueA.size()&gt;1)&#123; queueB.add(queueA.poll()); &#125; return queueA.poll(); &#125; &#125; public static void main(String[] args) throws Exception &#123; ImplStackByQueue implStackByQueue = new ImplStackByQueue(); ImplStackByQueue.push(2); ImplStackByQueue.push(4); ImplStackByQueue.push(0); System.out.println(ImplStackByQueue.pop()); ImplStackByQueue.push(10); ImplStackByQueue.push(20); System.out.println(ImplStackByQueue.pop()); &#125; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>execute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涘]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%B6%98%2F</url>
    <content type="text"><![CDATA[做一个执行者而不是计划者 Beginning从上周开始写博客开始，我就开始计划了我后面每天要做的事情;目前已经开始执行了一周，然后到了周天的总结时间； 牛客网刷题首先是每天早上在公交上刷Java基础题目，每天，很惨呐😭；可以看出来Java的基础真的很差劲，但是目前的阶段主要在补充一些数据结构与算法的知识，所以就每天早上挤公交的时候刷刷题，到下阶段着重看Java;总结：关于Java基础，我相信很多人和我一样，面象google编程；再就是看了源码但过了一段时间又忘记了，所以我选择了每天刷点题，着重提高对数据结构与算法的认知，希望几个月后我能得到自己的肯定； 数据结构与算法这里刷的是剑指offer，虽然很多不懂,走的很慢，但慢慢磨总归是可以磨出来的;这周主要做了两道算法题目：一道是：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList，另一道是：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。；其中链表的那道题目：给我印象最深的就是通过栈结构来实现的，这里充分地利用了栈结构先入后出的特性；以及递归方法，这也让我再次体会到了递归的强大；12345678910111213// 3.使用栈public ArrayList&lt;Integer&gt; printListFromTailToHeadStack(ListNode listNode)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while(listNode != null)&#123; stack.add(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while(!stack.isEmpty())&#123; ret.add(stack.pop()); &#125; return ret;&#125; 12345678910111213// 递归实现 - 把后面未遍历的当成一个整体，然后调用自己的方法，这样理解起来就很方便了LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(listNode != null)&#123; ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); //System.out.println(ret); &#125; System.out.println(ret); return ret; &#125; 然后关于树:学习了树的结构以及二叉树深度优先遍历和广度有限遍历,其中前序遍历,中序遍历,后序遍历三种深度遍历的方式。当然我自己根据题目给出的前两种遍历结构试着自己画了一下二叉树的结构，结果就是很容易把左边的树画出来，而右边的怎么都感觉不对劲；后面看了别人的思路也觉得画的有问题😚；可能还没有理解透彻，需要被再多折磨一下；总结：虽然算法在很多时候自己可能写不出来，但是硬着头皮去啃坚持一个阶段下来即使不能达到自己能随手写出来那种地步也会对整体的结构有一个比较清晰的脉络，值得深究； 关于SQL同样是在下午吃完饭回来进行练习，SQL的练习要比我想象中进展的快：计划是每周5道左右，目前来看貌似已经超两倍的完成；感觉牛客的SQL练习不大能起效果:就目前练习的来看基本都是两张表带点简单的条件以及排个序没有达到我想要的效果，可也能没做到后面的题目；改善：针对次可能需要进行改变一下，增加数据结构与算法的看书时间，先看算法书再练习SQL； 阶段总结目前来看，周一到周五基本能够完成上述的任务；周六周天主要写小程序和写文章、看书等任务周六和周天尚欠缺自制力，不能最大化的利用时间；希望能够有所改进；]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>execute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客从0到1]]></title>
    <url>%2F2019%2F05%2F02%2Fhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BB%8E0%E5%88%B01%2F</url>
    <content type="text"><![CDATA[写在开始这篇文章主要记录这两天倒腾的hexo个人博客系统从0到1的过程。 平台虽说是基于windows平台的搭建,但是很多命令都是一样的，所以想在Linux里面尝试的不妨倒腾两手 正文 Git的安装git是个好工具，和svn一样主要用于版本控制，我们需要在 git bush里面进行命令行的操作。有关git的相关知识可以到廖雪峰的网站进行学习； NodeJS的安装NodeJS也是个好东西，这玩意儿居然能写js的后端，一句话流批。NodeJS主要是用来管理和配置npm包的，安装完成需要配置一下环境变量，然后打开cmd，输入会有对应的版本号 12node -vnpm -v hexo的安装安装好工具之后开始操作：首先建立一个hexo文件的目录；例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装。 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后localhost:4000(默认开启4000端口)就能看到自己的静态资源站了 调整相关hexo样式这里一般就是先选好自己想用哪个主题样式用npm包clone下来，然后在主题文件夹下的配置文件改。如：日期啊，分页啊，用哪种样式等等，这里就不一一介绍了。这里可以参考hexo官网，看看它的目录结构以及受欢迎的主题。我看很多人用的Next主题，简洁而不简单 蛮不错的。 到这里应该都能访问到本机服务上的博客了。接下来主要做的就是将本地代码部署到远端GitHub上去。 部署到GitHub上并解析自己的域名 建立仓库值得注意的是，这里命名规则是账号名.github.io这个是后面你访问的域名(如果不绑定自己的域名的话) 设置git的名字和邮箱设置命令 1git config --global user.name &apos;账号名&apos; 查看是否设置成功的命令 1git config --global user.name 邮箱同理 1git config --global user.email &apos;邮箱&apos; 配置SSH密匙配置密匙命令 1ssh-keygen -t rsa -C &apos;邮箱名&apos; 查看是否设置成功 1ssh -T git@github.com 打开生成好密匙的文件id_rsa.pub，进入GitHubsetting--&gt;SSH and GPG keys--&gt;New SSH key复制粘贴保存 部署打开D:\hexo，用sublime或者VS code打开根目录下的_config.yml文件，文件最后可以看到 12deploy: type: 修改其配置 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github branch: master 然后就是一套,你可以选择将它们写到bat脚本执行文件里面去 123$ hexo clean$ hexo g$ hexo d 当然这里如果你没有安装部署的命令的话需要如下操作 1$ npm install hexo-deployer-git --save 这时，你就可以在浏览器里面输入https://yourname.github.io来进行访问你的博客了; 将域名解析到对应的GitHub仓库地址(可选)如果你有自己的域名的话或者你想拿自己的域名做链接的话，你需要到对应的云平台域名解析设置两条www和@的解析设置,其中记录类型为CNAME和记录值为账号名.github.io。进入{yourname}.github.io仓库--&gt;Settings-&gt;GitHub Pages保存好域名即可。到D:\hexo\sourse目录下（即你安装hexo的目录下的sourse目录下）新建文件CNAME，用Sublime或者VS code打开,填入你的域名，如jokerq.com，保存。然后到D:\hexo目录下用sublime打开_config.yml，ctrl+f查找skip_render，然后改为 123skip_render: - README.md - CNAME 最后就是执行你的bat文件，大功告成!]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>静态博客系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[逍惆]]></title>
    <url>%2F2019%2F04%2F28%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[小丑的世界逍惆的第一篇blog 列表1 列表2 a 子列表 b 子列表 列表3 小丑的世界 字体变斜 字体加粗 &lt;html&gt;&lt;/html&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是代码片段&lt;/title&gt; &lt;/head&gt; &lt;body&gt; conole.log(我是打印的函数); &lt;/body&gt;&lt;/html&gt; 引用别人的代码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>

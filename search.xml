<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洓]]></title>
    <url>%2F2019%2F06%2F02%2F%E6%B4%93%2F</url>
    <content type="text"><![CDATA[坚持有多难？ 写在开始本周共实现算法：温故而知新1234数组的二分查找 矩形递归 二分查找实现旋转数组的最小值 - 两种实现方式 非递归方式的二叉树的层次遍历以及中序遍历 &#160; &#160; &#160; &#160;现在渐渐开始养成了每天都往仓库提交点什么，无论提交的是理论的知识还是实现的代码，总归是记录成长的见证。 场景我们小时候玩的迷宫，走到死胡同返回再去寻找有出路的新节点，尝试新的路径，往复循环直到找到出口，那么它是怎么记录下来路径，又是怎么去寻找到新节点的？微博和微信，用户之间能够互相关注和互相添加好友；抖音等系统机制能给你推荐你的好友，以及地图的最远和最近等机制怎么实现的？ 图上周认识到了图这种数据结构，发现这种数据结构真的是好啊。然后我越来越真切地感受到，很多知识都是基于生活演变而来，仔细一想很多知识不就是为了解决生活中问题的么。 什么是图?图由顶点集合与描述各顶点之间边组成的一种数据结构图分为有向和无向如下图是有向图和无向图两种：我们都知道在使用的地图(无论是百度地图还是高德地图)它们都有帮我识别远近的，以及推荐最优解的功能那是怎么实现的？事实上，这里引入了一个概念带权图:在每个顶点之间的边上都会有一个权重(weight)，通过它的和，会知道那条路径会更短以及用时最快 图的储存图存储方式有链表+数组和邻接矩阵储存的过程如上图，需要求解时间最少，距离最短，权值最小的最短路径通过一种算法：狄克斯特拉算法上图中共有8个地方，初始用如下方法记录 - 暂且认为从起点到v2-v8的距离均为-1(无穷大)12345678910S数组 v1T数组 v2 v3 v4 v5 v6 v7 v8前一个节点 当前节点 权重 v2 -1 v3 -1 v4 -1 v5 -1 v6 -1 v7 -1 v8 -1 经过最终的运算得到如下数组:12345678910111213141516s数组 v1 v2 v3 v4 v6 v7 v5 v8t数组前一个节点 当前节点 权重 v1 v2 3 v2 v3 4 v3 v4 5 v6 v5 8 v3 v6 6 v6 v7 7 v7 v8 12最短路径路线 v1 v2 v3 v6 v7 v8 12 3 1 2 1 5下面的数字代表的是：各个节点之间的距离 【最终结果表】 从上面那种表可以看出来，我们能够得到从v1到v2、v3等各个点之间的最短距离；狄克斯特拉算法实现过程：首先是：v1节点到最近的三个节点v2、v3、v4以及他们的权重是否大于初始值(-1)。如果大于则进行更新,所以得到如下：123456789101112131415161718192021222324252627v1节点： 前一个节点 当前节点 权重 上一个节点到当前节点的权重值 v1 v2 -1 3 v1 v3 -1 5 v1 v4 -1 6 v5 -1 v6 -1 v7 -1 v8 -1更新完了之后：将原本的`-1`替换掉最新的权重值, 如果[权重小于原本的权重]则进行替换 前一个节点 当前节点 权重 v1 v2 3 v1 v3 5 v1 v4 6 v5 -1 v6 -1 v7 -1 v8 -1数组表一： s数组 v1 v2 t数组 v3 v4 v5 v6 v7 v8 【表格一】 然后接下来，在【上一个节点到当前节点的权重值】这一栏中找到最小的值，即[3] - 对应当前节点最小的值：v2 ，得到【表格一】中的数组表一;1v1能到达的顶点已经走完了，现在看v2的能到达的顶点路径 1234567891011121314151617181920212223242526272829v2节点 - 能到最近节点的图 - (v5、v6、v3) - 则路径为[v1-v2-v3]、[v1-v2-v5]、[v1-v2-v6] 前一个节点 当前节点 权重 上一个节点到当前节点的权重值 v1 v2 3 v1 v3 5 1 v1 v4 6 v5 -1 v6 -1 7 v7 -1 4 v8 -1 更新完了之后：将原本的`-1`替换掉最新的权重值，如果[权重小于原本的权重]则进行替换，以及[前一个节点的名称] 前一个节点 当前节点 权重 v1 v2 3 v2 v3 1+3 v1 v4 6 v2 v5 7+3 v2 v6 4+3 v7 -1 v8 -1 数组表二： s数组 v1 v2 v3 t数组 v4 v5 v6 v7 v8 【表格二】 接下来就是循环前面的操作，直到走完v1-v8的所有路径，得到最终结果表详情可以了解 &nbsp;&nbsp; b站上面尚学堂的数据结构与算法 申明文章中的图片均非本人的原创，转自极客时间-王争专栏的图，若有打扰请联系本人进行删除;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>execute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[澑]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%BE%91%2F</url>
    <content type="text"><![CDATA[出口在哪？ 写在开始本周有一个需求：就是需要完成一颗树结构]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>execute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鋈]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%8B%88%2F</url>
    <content type="text"><![CDATA[路漫漫 写在开始刷题和sql在以后就只记录一些有意思的题目或分析；如：关于几个常见算法的时间复杂度分析案例：12345678(1).交换i和j的内容 sum=0; (一次) for(int i=0;i&lt;=n;i++&gt;)&#123; (n次) for(j=1;j&lt;=n;j++&gt;)&#123; (n^2次) sum++; (n^2次) &#125; &#125;则时间复杂度T(n) = 1+n+2*n^2 取最高次的影响则为 T(n) = O(n^2) 1234567(2). for (i=1;i&lt;n;i++)&#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) (因为j能取到2n所以为：2n+1) x++; ② &#125; ① 的时间复杂度是(n-1)、② 的时间复杂度是(n-1)(2n+1) 则时间复杂度为T(n) = O(n-1)+(n-1)(2n+1) = O(n^2) 12345678(3). a=0; b=1; ① (1次) for(i=1;i&lt;=n;i++)&#123; ② (n+1次) s=a+b; ③ (n次) b=a; ④ (n次) a=s; ⑤ (n次) &#125; 则时间复杂度为：T(n) = 4n = O(n) 为线性的函数 123456(4). i=1; ① 1 while(i&lt;=n&gt;)&#123; i=i*2; ② 2^f(n)&lt;=n;f(n)&lt;=log2n &#125; T(n)=O(log2n) 这里频次本身是一个函数，则可求得函数本身f(n)的值 本周实现算法 1.用两个栈实现队列 - 完成基本的出队和入队的功能 123456789101112131415161718192021222324252627282930313233343536373839404142/*基本分析：由于栈和队列的两种结构是完全相反的*/ public class ImplQueueByStack&#123; // 定义两个栈 Stack&lt;Integer&gt; stackA = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stackB = new Stack&lt;Integer&gt;(); // 定义入队的方法 public void push(int node)&#123; // 将栈A当作队列的入口 stackA.push(node); &#125; // 队列的出队方法 public int pop() throws Exception&#123; if(stackA.isEmpty() &amp;&amp; stackB.isEmpty())&#123; throw new Exception(&quot;队列为空&quot;); &#125; // 将栈B当作队列的出口,拿到栈A中的最后一个元素进行出栈 if(stackB.isEmpty())&#123; // 如果栈B为空的话，遍历栈A往栈B中添加元素 while(!stackA.isEmpty())&#123; stackB.push(stackA.pop()); &#125; &#125; // 添加返回值 return stackB.pop(); &#125; // 测试方法 public static void main(String[] args) throws Exception &#123; ImplQueueByStack implQueueByStack = new ImplQueueByStack(); implQueueByStack.push(2); implQueueByStack.push(4); implQueueByStack.push(0); System.out.println(implQueueByStack.pop()); implQueueByStack.push(10); implQueueByStack.push(20); System.out.println(implQueueByStack.pop()); &#125; &#125; 2.用两个队列实现栈 - 完成基本的出队和入队的功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public class ImplStackByQueue&#123; // 定义两个队列 Queue&lt;Integer&gt; queueA = new Queue&lt;Integer&gt;(); Queue&lt;Integer&gt; queueB = new Queue&lt;Integer&gt;(); //定义队列的入队方法 public void push(int node)&#123; // 如果队列A为空，则队列B Push if(queueA.isEmpty())&#123; queueB.push(node); &#125; if(queueB.isEmpty())&#123; queueA.push(node); &#125; // 如果两个队列均为空的话，使用队列A优先 if(queueA.isEmpty() &amp;&amp; queueB.isEmpty())&#123; queueA.push(node); &#125; &#125; // 定义出队的方法 public int pop() throws Exception&#123; if(queueA.isEmpty() &amp;&amp; queueB.isEmpty())&#123; throw new Exception(&quot;栈为空&quot;); &#125;// 如果queueA为空，queueB不为空，将queueB的元素依次放入queueA，直到queueB中最后一个元素弹出 if(!queueA.isEmpty())&#123; while(queueB.size()&gt;1)&#123; queueA.add(queueB.poll()); &#125; return queueB.poll(); &#125; if(!queueB.isEmpty())&#123; while(queueA.size()&gt;1)&#123; queueB.add(queueA.poll()); &#125; return queueA.poll(); &#125; &#125; public static void main(String[] args) throws Exception &#123; ImplStackByQueue implStackByQueue = new ImplStackByQueue(); ImplStackByQueue.push(2); ImplStackByQueue.push(4); ImplStackByQueue.push(0); System.out.println(ImplStackByQueue.pop()); ImplStackByQueue.push(10); ImplStackByQueue.push(20); System.out.println(ImplStackByQueue.pop()); &#125; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>execute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涘]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%B6%98%2F</url>
    <content type="text"><![CDATA[做一个执行者而不是计划者 Beginning从上周开始写博客开始，我就开始计划了我后面每天要做的事情;目前已经开始执行了一周，然后到了周天的总结时间； 牛客网刷题首先是每天早上在公交上刷Java基础题目，每天，很惨呐😭；可以看出来Java的基础真的很差劲，但是目前的阶段主要在补充一些数据结构与算法的知识，所以就每天早上挤公交的时候刷刷题，到下阶段着重看Java;总结：关于Java基础，我相信很多人和我一样，面象google编程；再就是看了源码但过了一段时间又忘记了，所以我选择了每天刷点题，着重提高对数据结构与算法的认知，希望几个月后我能得到自己的肯定； 数据结构与算法这里刷的是剑指offer，虽然很多不懂,走的很慢，但慢慢磨总归是可以磨出来的;这周主要做了两道算法题目：一道是：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList，另一道是：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。；其中链表的那道题目：给我印象最深的就是通过栈结构来实现的，这里充分地利用了栈结构先入后出的特性；以及递归方法，这也让我再次体会到了递归的强大；12345678910111213// 3.使用栈public ArrayList&lt;Integer&gt; printListFromTailToHeadStack(ListNode listNode)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while(listNode != null)&#123; stack.add(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while(!stack.isEmpty())&#123; ret.add(stack.pop()); &#125; return ret;&#125; 12345678910111213// 递归实现 - 把后面未遍历的当成一个整体，然后调用自己的方法，这样理解起来就很方便了LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(listNode != null)&#123; ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); //System.out.println(ret); &#125; System.out.println(ret); return ret; &#125; 然后关于树:学习了树的结构以及二叉树深度优先遍历和广度有限遍历,其中前序遍历,中序遍历,后序遍历三种深度遍历的方式。当然我自己根据题目给出的前两种遍历结构试着自己画了一下二叉树的结构，结果就是很容易把左边的树画出来，而右边的怎么都感觉不对劲；后面看了别人的思路也觉得画的有问题😚；可能还没有理解透彻，需要被再多折磨一下；总结：虽然算法在很多时候自己可能写不出来，但是硬着头皮去啃坚持一个阶段下来即使不能达到自己能随手写出来那种地步也会对整体的结构有一个比较清晰的脉络，值得深究； 关于SQL同样是在下午吃完饭回来进行练习，SQL的练习要比我想象中进展的快：计划是每周5道左右，目前来看貌似已经超两倍的完成；感觉牛客的SQL练习不大能起效果:就目前练习的来看基本都是两张表带点简单的条件以及排个序没有达到我想要的效果，可也能没做到后面的题目；改善：针对次可能需要进行改变一下，增加数据结构与算法的看书时间，先看算法书再练习SQL； 阶段总结目前来看，周一到周五基本能够完成上述的任务；周六周天主要写小程序和写文章、看书等任务周六和周天尚欠缺自制力，不能最大化的利用时间；希望能够有所改进；]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>execute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客从0到1]]></title>
    <url>%2F2019%2F05%2F02%2Fhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BB%8E0%E5%88%B01%2F</url>
    <content type="text"><![CDATA[写在开始这篇文章主要记录这两天倒腾的hexo个人博客系统从0到1的过程。 平台虽说是基于windows平台的搭建,但是很多命令都是一样的，所以想在Linux里面尝试的不妨倒腾两手 正文 Git的安装git是个好工具，和svn一样主要用于版本控制，我们需要在 git bush里面进行命令行的操作。有关git的相关知识可以到廖雪峰的网站进行学习； NodeJS的安装NodeJS也是个好东西，这玩意儿居然能写js的后端，一句话流批。NodeJS主要是用来管理和配置npm包的，安装完成需要配置一下环境变量，然后打开cmd，输入会有对应的版本号 12node -vnpm -v hexo的安装安装好工具之后开始操作：首先建立一个hexo文件的目录；例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装。 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后localhost:4000(默认开启4000端口)就能看到自己的静态资源站了 调整相关hexo样式这里一般就是先选好自己想用哪个主题样式用npm包clone下来，然后在主题文件夹下的配置文件改。如：日期啊，分页啊，用哪种样式等等，这里就不一一介绍了。这里可以参考hexo官网，看看它的目录结构以及受欢迎的主题。我看很多人用的Next主题，简洁而不简单 蛮不错的。 到这里应该都能访问到本机服务上的博客了。接下来主要做的就是将本地代码部署到远端GitHub上去。 部署到GitHub上并解析自己的域名 建立仓库值得注意的是，这里命名规则是账号名.github.io这个是后面你访问的域名(如果不绑定自己的域名的话) 设置git的名字和邮箱设置命令 1git config --global user.name &apos;账号名&apos; 查看是否设置成功的命令 1git config --global user.name 邮箱同理 1git config --global user.email &apos;邮箱&apos; 配置SSH密匙配置密匙命令 1ssh-keygen -t rsa -C &apos;邮箱名&apos; 查看是否设置成功 1ssh -T git@github.com 打开生成好密匙的文件id_rsa.pub，进入GitHubsetting--&gt;SSH and GPG keys--&gt;New SSH key复制粘贴保存 部署打开D:\hexo，用sublime或者VS code打开根目录下的_config.yml文件，文件最后可以看到 12deploy: type: 修改其配置 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github branch: master 然后就是一套,你可以选择将它们写到bat脚本执行文件里面去 123$ hexo clean$ hexo g$ hexo d 当然这里如果你没有安装部署的命令的话需要如下操作 1$ npm install hexo-deployer-git --save 这时，你就可以在浏览器里面输入https://yourname.github.io来进行访问你的博客了; 将域名解析到对应的GitHub仓库地址(可选)如果你有自己的域名的话或者你想拿自己的域名做链接的话，你需要到对应的云平台域名解析设置两条www和@的解析设置,其中记录类型为CNAME和记录值为账号名.github.io。进入{yourname}.github.io仓库--&gt;Settings-&gt;GitHub Pages保存好域名即可。到D:\hexo\sourse目录下（即你安装hexo的目录下的sourse目录下）新建文件CNAME，用Sublime或者VS code打开,填入你的域名，如jokerq.com，保存。然后到D:\hexo目录下用sublime打开_config.yml，ctrl+f查找skip_render，然后改为 123skip_render: - README.md - CNAME 最后就是执行你的bat文件，大功告成!]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>静态博客系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[逍惆]]></title>
    <url>%2F2019%2F04%2F28%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[小丑的世界逍惆的第一篇blog 列表1 列表2 a 子列表 b 子列表 列表3 小丑的世界 字体变斜 字体加粗 &lt;html&gt;&lt;/html&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是代码片段&lt;/title&gt; &lt;/head&gt; &lt;body&gt; conole.log(我是打印的函数); &lt;/body&gt;&lt;/html&gt; 引用别人的代码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
